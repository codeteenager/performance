import{_ as e,c as a,o as i,a as l}from"./app.75d52317.js";const v=JSON.parse('{"title":"JavaScript优化","description":"","frontmatter":{},"headers":[{"level":2,"title":"提升JS文件加载性能","slug":"提升js文件加载性能","link":"#提升js文件加载性能","children":[]},{"level":2,"title":"JS变量和函数优化","slug":"js变量和函数优化","link":"#js变量和函数优化","children":[]},{"level":2,"title":"JS动画优化","slug":"js动画优化","link":"#js动画优化","children":[]},{"level":2,"title":"DOM编程优化","slug":"dom编程优化","link":"#dom编程优化","children":[{"level":3,"title":"控制DOM大小","slug":"控制dom大小","link":"#控制dom大小","children":[]},{"level":3,"title":"简化DOM操作","slug":"简化dom操作","link":"#简化dom操作","children":[]}]},{"level":2,"title":"合理使用缓存","slug":"合理使用缓存","link":"#合理使用缓存","children":[]},{"level":2,"title":"JavaScript的开销和如何缩短解析时间","slug":"javascript的开销和如何缩短解析时间","link":"#javascript的开销和如何缩短解析时间","children":[]}],"relativePath":"optimization/code/javascript.md","lastUpdated":1672803901000}'),t={name:"optimization/code/javascript.md"},r=l('<h1 id="javascript优化" tabindex="-1">JavaScript优化 <a class="header-anchor" href="#javascript优化" aria-hidden="true">#</a></h1><p>JS优化的原则是当需要时才优化，没有必要每次项目开发时都要优化，而是当项目有大的改版，代码无法维护时去考虑做优化。优化完后考虑其维护性。</p><h2 id="提升js文件加载性能" tabindex="-1">提升JS文件加载性能 <a class="header-anchor" href="#提升js文件加载性能" aria-hidden="true">#</a></h2><ul><li>加载元素的顺序CSS文件放在<code>&lt;head&gt;</code>里，JS文件放在<code>&lt;body&gt;</code>里</li></ul><h2 id="js变量和函数优化" tabindex="-1">JS变量和函数优化 <a class="header-anchor" href="#js变量和函数优化" aria-hidden="true">#</a></h2><ul><li>尽量使用id选择器，id选择器查询是最快的</li><li>尽量避免使用eval，eval非常损耗性能</li><li>JS函数尽可能保持简洁</li><li>使用事件节流函数</li><li>使用事件委托，当我们ul下有li、a等标签，设置点击事件的时候可以设置在父元素ul中。</li></ul><h2 id="js动画优化" tabindex="-1">JS动画优化 <a class="header-anchor" href="#js动画优化" aria-hidden="true">#</a></h2><ul><li>避免添加大量JS动画</li><li>尽量使用CSS3动画</li><li>尽量使用Canvas动画</li><li>合理使用requestAnimationFrame动画代替setTimeout、setInterval，requestAnimationFrame可以在正确时间进行渲染，setTimeout和setInterval无法保证callback回调函数的执行时机</li></ul><h2 id="dom编程优化" tabindex="-1">DOM编程优化 <a class="header-anchor" href="#dom编程优化" aria-hidden="true">#</a></h2><h3 id="控制dom大小" tabindex="-1">控制DOM大小 <a class="header-anchor" href="#控制dom大小" aria-hidden="true">#</a></h3><p>众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量DOM元素。想象一下，从一个上万节点的DOM树上，使用querySelectorAll或getElementByTagName方法查找一个节点，是非常耗时的。另外元素绑定事件，事件冒泡和事件捕获的执行也会相对耗时。</p><p>通常控制DOM大小的技巧包括：</p><ul><li>合理的业务逻辑</li><li>延迟加载即将呈现的内容</li></ul><h3 id="简化dom操作" tabindex="-1">简化DOM操作 <a class="header-anchor" href="#简化dom操作" aria-hidden="true">#</a></h3><ul><li>对DOM节点的操作统一处理后，再统一插入到DOM Tree中。</li><li>可以使用fragment，尽量不在页面DOM Tree里直接操作。</li><li>现在流行的框架Angular、React、Vue都在使用虚拟DOM技术，通过diff算法简化和减少DOM操作。</li></ul><h2 id="合理使用缓存" tabindex="-1">合理使用缓存 <a class="header-anchor" href="#合理使用缓存" aria-hidden="true">#</a></h2><ul><li>合理缓存DOM对象，浏览器每次查询DOM对象很消耗时间</li><li>缓存列表长度，把列表下li的长度缓存起来，不需要每次查询列表长度</li><li>使用可缓存的ajax</li></ul><h2 id="javascript的开销和如何缩短解析时间" tabindex="-1">JavaScript的开销和如何缩短解析时间 <a class="header-anchor" href="#javascript的开销和如何缩短解析时间" aria-hidden="true">#</a></h2><p>我们加载的资源有很多种，例如JCSS、图片、字体等，这些资源大小也有可能非常大，但是JavaScript仍然是这里面非常昂贵的。因为JavaScript除了加载过程中有开销，它在后面还需要经历解析和编译的过程，解析和编译之后才执行，后面这两步也非常耗时。</p>',19),d=[r];function s(n,c,h,o,u,p){return i(),a("div",null,d)}const S=e(t,[["render",s]]);export{v as __pageData,S as default};
