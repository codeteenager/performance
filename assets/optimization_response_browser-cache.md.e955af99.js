import{_ as e,c as o,o as a,a as i}from"./app.4d4785f4.js";const S=JSON.parse('{"title":"浏览器存储","description":"","frontmatter":{},"headers":[{"level":2,"title":"Cookie","slug":"cookie","link":"#cookie","children":[{"level":3,"title":"Cookie的特点","slug":"cookie的特点","link":"#cookie的特点","children":[]},{"level":3,"title":"Cookie的优化","slug":"cookie的优化","link":"#cookie的优化","children":[]}]},{"level":2,"title":"LocalStorage","slug":"localstorage","link":"#localstorage","children":[]},{"level":2,"title":"SessionStorage","slug":"sessionstorage","link":"#sessionstorage","children":[{"level":3,"title":"优化点","slug":"优化点","link":"#优化点","children":[]}]},{"level":2,"title":"IndexedDB","slug":"indexeddb","link":"#indexeddb","children":[]}],"relativePath":"optimization/response/browser-cache.md","lastUpdated":1670862197000}'),r={name:"optimization/response/browser-cache.md"},s=i('<h1 id="浏览器存储" tabindex="-1">浏览器存储 <a class="header-anchor" href="#浏览器存储" aria-hidden="true">#</a></h1><h2 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-hidden="true">#</a></h2><p>Cookie常见业务场景是：用Cookie给服务端传递相关信息，让服务端分辨当前进行请求的是哪个客户端。Cookie是1993年诞生的，它的目的就是为了区分http请求它的客户端的情况。因为HTTP请求是无状态的，无状态是指当HTTP请求结束后，它的连接就关闭了。那么下一次请求，服务端就不会知道这个请求和之前的某个请求来自同一客户端，它不能跟踪HTTP请求它的会话情况。那么这样我们就产生登录信息、用户信息的维护问题，所以需要Cookie去维护客户端的状态。</p><p>Cookie的生成可以通过服务端HTTP Response Header的set-cookie的返回，当浏览器检测到服务端返回的Response Header中有cookie的信息，就会把信息内容存储到客户端的Cookie存储区域中。这样每次请求服务端的时候都会携带上Cookie，服务端就知道该请求来自于哪个客户端。</p><p>第二种Cookie生成的方式是通过JS调用document.cookie的方式可以读写cookie的内容。</p><p>所以Cookie有两种作用，一种是用于浏览器端和服务器端的交互，另一种是客户端自身数据的存储。</p><h3 id="cookie的特点" tabindex="-1">Cookie的特点 <a class="header-anchor" href="#cookie的特点" aria-hidden="true">#</a></h3><p>Cookie它主要有以下特点</p><ul><li>作为浏览器存储，大小只有4KB左右</li><li>需要设置过期时间expire</li><li>设置httponly不允许js读写，防止黑客攻击</li></ul><p>所以在localstorage出现之后cookie存储数据能力就被localstorage取代了。</p><h3 id="cookie的优化" tabindex="-1">Cookie的优化 <a class="header-anchor" href="#cookie的优化" aria-hidden="true">#</a></h3><p>由于cookie在访问对应域名下的资源时都会通过HTTP请求发送到服务器，尤其是js、css静态资源，不需要携带cookie，因此会造成CDN的流量损耗，所以建议将CDN的域名和主站域名分开。</p><h2 id="localstorage" tabindex="-1">LocalStorage <a class="header-anchor" href="#localstorage" aria-hidden="true">#</a></h2><p>由于cookie在本地存储的各种不便，所以在HTML5中设计出了专门用于浏览器存储的LocalStorage。它的大小在5M左右，它仅仅只在客户端使用，不和服务器端进行通信。它的接口封装较好，在js中提供localstorage的api进行读写。它是作为浏览器缓存方案而存在，例如我们请求一个网站页面，该页面由于网络导致请求资源较慢，一些网站信息需要请求接口来获取再显示，而有些网站信息是暂时不变得，那么我们就直接进行存储，再次请求的时候从缓存获取数据显示即可，等到接口请求过来后再替换存储的数据。所以我们经常用LocalStorage来作为缓存，优化首屏渲染。</p><h2 id="sessionstorage" tabindex="-1">SessionStorage <a class="header-anchor" href="#sessionstorage" aria-hidden="true">#</a></h2><p>SessionStorage和LocalStorage的区别是它是一个会话级别的浏览器存储，例如浏览器的一个标签页就是一个会话，当标签页关闭后，该存储就清空了。它的大小在5M左右，它仅仅只在客户端使用，不和服务器端进行通信。它的接口封装较好。</p><h3 id="优化点" tabindex="-1">优化点 <a class="header-anchor" href="#优化点" aria-hidden="true">#</a></h3><p>SessionStorage它的优化点在交互优化上，主要是用于对表单信息的维护，例如我们填写表单信息之后，刷新了浏览器，导致之前填写的信息没有了，交互体验很差，那么我们就可以使用SessionStorage进行存储，刷新页面之后把信息从SessionStorage获取回显到表单中，当关闭标签页之后就清空信息，重新打开页面是空的就重新填写。</p><p>其次SessionStorage也可以作为多页面表单的信息存储，例如我们将一个表单填写拆分成多个页面，有第一步、第二布，当我们在第二布编写完后不小心回退到上一步了，我们也需要把之前页面的信息维护起来，因为这个信息是整个表单的信息，所以可以用SessionStorage来进行存储。</p><h2 id="indexeddb" tabindex="-1">IndexedDB <a class="header-anchor" href="#indexeddb" aria-hidden="true">#</a></h2><p>IndexDB是一种低级API，用于客户端存储大量结构化数据。该API使用索引来实现对该数据的高性能搜索。虽然Web Storage对于存储较少量的数据很有用，但是对于存储更大量的结构化数据来说，这种方法不太有用,IndexDB提供了一个解决方案</p>',21),t=[s];function l(n,d,c,h,p,k){return a(),o("div",null,t)}const _=e(r,[["render",l]]);export{S as __pageData,_ as default};
