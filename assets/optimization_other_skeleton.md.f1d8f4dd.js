import{_ as e,c as a,o as t,a as i}from"./app.1727c0d7.js";const u=JSON.parse('{"title":"骨架屏","description":"","frontmatter":{},"headers":[{"level":2,"title":"技术方案","slug":"技术方案","link":"#技术方案","children":[]}],"relativePath":"optimization/other/skeleton.md","lastUpdated":1670948464000}'),o={name:"optimization/other/skeleton.md"},n=i('<h1 id="骨架屏" tabindex="-1">骨架屏 <a class="header-anchor" href="#骨架屏" aria-hidden="true">#</a></h1><p>骨架屏其实就是在页面加载内容之前，先给用户展示出页面的大致结构，再等拿到接口数据后在将内容替换，较传统的菊花 loading 效果会给用户一种“已经渲染一部分出来了”的错觉，在效果上可以一定程度的提升用户体验。本质上就是视觉过渡的一个效果，以此来降低用户在等待时候的焦灼情绪。</p><h2 id="技术方案" tabindex="-1">技术方案 <a class="header-anchor" href="#技术方案" aria-hidden="true">#</a></h2><p>骨架屏技术方案上从实现上来说大致可以三类：</p><ul><li>手动维护骨架屏的代码（HTML、css or vue 、React）</li><li>使用图片作为骨架屏</li><li>自动生成骨架屏</li></ul><p>对于前两种方案有一定的维护成本比较费人力，这里主要介绍下自动生成骨架屏的方案。</p><p>目前市面上主要使用的是饿了么开源的 webpack 插件：page-skeleton-webpack-plugin。它根据项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。这种方式将骨架屏代码与业务代码隔离，通过 webpack 注入的方式骨架屏代码（图片）注入到项目中。优势非常明显但是缺点也显而易见：webpack配置成本（还依赖html-webpack-plugin）。</p>',7),l=[n];function r(s,c,p,_,d,h){return t(),a("div",null,l)}const m=e(o,[["render",r]]);export{u as __pageData,m as default};
